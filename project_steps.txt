Repo scaffold: create folders app/, sql/, data/, artifacts/, add requirements.txt, Dockerfile, docker-compose.yml, and a minimal README.
Schema setup: drop the provided SQL into sql/001_schema.sql; wire PG_DSN env; include cost_rates seeding data.
Classifier data: gather/label prompts (heuristics â†’ human clean-up), split into train/val JSONL in data/.
Train classifier: run train_classifier.py to fine-tune Phi-3 mini; save to artifacts/phi3-difficulty-classifier/; record metrics.
FastAPI skeleton: implement /generate with difficulty prediction, routing policy, token counting stub, cost calculation stub, provider call stubs, and DB logging.
Routing policy hardening: add guardrails (length/context escalation, unsafe/PII precheck), confidence thresholds, retry/escalation logic.
Plug real models: integrate actual clients for Phi-3/Llama-3/GPT-4o, real token counting, real price lookup from cost_rates.
Logging/metrics: ensure requests persisted with provider IDs; add basic latency and error logging; add health/ready endpoints.
Analytics job: add a lightweight batch/cron to compute pass rate, win rate, and cost deltas; store into model_eval or a summary table.
Dashboard hookup: connect Grafana/Metabase to Postgres; add starter queries for cost per day, model mix, latency distribution, quality vs. cost.
Testing: unit tests for routing decisions and price calc; integration test for /generate happy path + fallback.
Containerization: build and run docker compose up --build; verify API and DB init; add Compose overrides for prod (timeouts, healthchecks).
Ops hardening: rate limiting/backoff, timeouts per model, response quality heuristics, versioning model IDs, secrets/env handling.